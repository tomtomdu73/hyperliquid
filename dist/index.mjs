var C={PRODUCTION:"https://api.hyperliquid.xyz",TESTNET:"https://api.hyperliquid-testnet.xyz"},B={PRODUCTION:"wss://api.hyperliquid.xyz/ws",TESTNET:"wss://api.hyperliquid-testnet.xyz/ws"},y={ARBITRUM_MAINNET:"0xa4b1",ARBITRUM_TESTNET:"0x66eee"},_={INFO:"/info",EXCHANGE:"/exchange"};var $="PLACEHOLDER";var M=class{constructor(e,t,s){this.httpApi=e;this.symbolConversion=t;this.parent=s}parent;async getAllMids(e=!1){let t=await this.httpApi.makeRequest({type:"allMids"});if(e)return t;{let s={};for(let[i,n]of Object.entries(t)){let r=await this.symbolConversion.convertSymbol(i),o=parseFloat(n);s[r]=o}return s}}async getUserOpenOrders(e,t=!1){await this.parent.ensureInitialized();let s=await this.httpApi.makeRequest({type:"openOrders",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getFrontendOpenOrders(e,t=!1){let s=await this.httpApi.makeRequest({type:"frontendOpenOrders",user:e},20);return t?s:await this.symbolConversion.convertResponse(s)}async getUserFills(e,t=!1){let s=await this.httpApi.makeRequest({type:"userFills",user:e},20);return t?s:await this.symbolConversion.convertResponse(s)}async getUserFillsByTime(e,t,s,i=!1){let n={user:e,startTime:Math.round(t),type:"userFillsByTime"};s&&(n.endTime=Math.round(s));let r=await this.httpApi.makeRequest(n,20);return i?r:await this.symbolConversion.convertResponse(r)}async getUserRateLimit(e,t=!1){let s=await this.httpApi.makeRequest({type:"userRateLimit",user:e},20);return t?s:await this.symbolConversion.convertResponse(s)}async getOrderStatus(e,t,s=!1){let i=await this.httpApi.makeRequest({type:"orderStatus",user:e,oid:t});return s?i:await this.symbolConversion.convertResponse(i)}async getL2Book(e,t=!1,s=5,i=void 0){let n=await this.httpApi.makeRequest({type:"l2Book",coin:await this.symbolConversion.convertSymbol(e,"reverse"),nSigFigs:s,mantissa:i});return t?n:await this.symbolConversion.convertResponse(n)}async getCandleSnapshot(e,t,s,i,n=!1){let r=await this.httpApi.makeRequest({type:"candleSnapshot",req:{coin:await this.symbolConversion.convertSymbol(e,"reverse"),interval:t,startTime:s,endTime:i}});return n?r:await this.symbolConversion.convertResponse(r,["s"])}async getMaxBuilderFee(e,t,s=!1){let i=await this.httpApi.makeRequest({type:"maxBuilderFee",user:e,builder:t});return s?i:this.symbolConversion.convertToNumber(i)}async getHistoricalOrders(e,t=!1){let s=await this.httpApi.makeRequest({type:"historicalOrders",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getUserTwapSliceFills(e,t=!1){let s=await this.httpApi.makeRequest({type:"userTwapSliceFills",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getSubAccounts(e,t=!1){let s=await this.httpApi.makeRequest({type:"subAccounts",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getVaultDetails(e,t,s=!1){let i={type:"vaultDetails",vaultAddress:e};t&&(i.user=t);let n=await this.httpApi.makeRequest(i);return s?n:await this.symbolConversion.convertResponse(n)}async getUserVaultEquities(e,t=!1){let s=await this.httpApi.makeRequest({type:"userVaultEquities",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getUserRole(e,t=!1){let s=await this.httpApi.makeRequest({type:"userRole",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getDelegations(e,t=!1){let s=await this.httpApi.makeRequest({type:"delegations",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getDelegatorSummary(e,t=!1){let s=await this.httpApi.makeRequest({type:"delegatorSummary",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getDelegatorHistory(e,t=!1){let s=await this.httpApi.makeRequest({type:"delegatorHistory",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getDelegatorRewards(e,t=!1){let s=await this.httpApi.makeRequest({type:"delegatorRewards",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async validatorSummaries(e=!1){let t=await this.httpApi.makeRequest({type:"validatorSummaries"});return e?t:await this.symbolConversion.convertResponse(t)}async vaultSummaries(e=!1){let t=await this.httpApi.makeRequest({type:"vaultSummaries"});return e?t:await this.symbolConversion.convertResponse(t)}async userFees(e,t=!1){let s=await this.httpApi.makeRequest({type:"userFees",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async portfolio(e,t=!1){let s=await this.httpApi.makeRequest({type:"portfolio",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async preTransferCheck(e,t,s=!1){let i=await this.httpApi.makeRequest({type:"preTransferCheck",user:e,source:t});return s?i:await this.symbolConversion.convertResponse(i)}async referral(e,t=!1){let s=await this.httpApi.makeRequest({type:"referral",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async extraAgents(e,t=!1){let s=await this.httpApi.makeRequest({type:"extraAgents",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async isVip(e,t=!1){let s=await this.httpApi.makeRequest({type:"isVip",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async legalCheck(e,t=!1){let s=await this.httpApi.makeRequest({type:"legalCheck",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async userTwapSliceFillsByTime(e,t,s,i,n=!1){let r={type:"userTwapSliceFillsByTime",user:e,startTime:t};s!==void 0&&(r.endTime=s),i!==void 0&&(r.aggregateByTime=i);let o=await this.httpApi.makeRequest(r);return n?o:await this.symbolConversion.convertResponse(o)}async twapHistory(e,t=!1){let s=await this.httpApi.makeRequest({type:"twapHistory",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async userToMultiSigSigners(e,t=!1){let s=await this.httpApi.makeRequest({type:"userToMultiSigSigners",user:e});return t?s:await this.symbolConversion.convertResponse(s)}};var k=class{httpApi;symbolConversion;constructor(e,t){this.httpApi=e,this.symbolConversion=t}async getSpotMeta(e=!1){let t=await this.httpApi.makeRequest({type:"spotMeta"});return e?t:await this.symbolConversion.convertResponse(t,["name","coin","symbol"],"SPOT")}async getSpotClearinghouseState(e,t=!1){let s=await this.httpApi.makeRequest({type:"spotClearinghouseState",user:e});return t?s:await this.symbolConversion.convertResponse(s,["name","coin","symbol"],"SPOT")}async getSpotMetaAndAssetCtxs(e=!1){let t=await this.httpApi.makeRequest({type:"spotMetaAndAssetCtxs"});return e?t:await this.symbolConversion.convertResponse(t)}async getTokenDetails(e,t=!1){let s=await this.httpApi.makeRequest({type:"tokenDetails",tokenId:e},20);return t?s:await this.symbolConversion.convertResponse(s)}async getSpotDeployState(e,t=!1){let s=await this.httpApi.makeRequest({type:"spotDeployState",user:e},20);return t?s:await this.symbolConversion.convertResponse(s)}};var D=class{httpApi;symbolConversion;parent;constructor(e,t,s){this.httpApi=e,this.symbolConversion=t,this.parent=s}async getMeta(e=!1){let t=await this.httpApi.makeRequest({type:"meta"});return e?t:await this.symbolConversion.convertResponse(t,["name","coin","symbol"],"PERP")}async getMetaAndAssetCtxs(e=!1){let t=await this.httpApi.makeRequest({type:"metaAndAssetCtxs"});return e?t:await this.symbolConversion.convertResponse(t,["name","coin","symbol"],"PERP")}async getClearinghouseState(e,t=!1){let s=await this.httpApi.makeRequest({type:"clearinghouseState",user:e});return t?s:await this.symbolConversion.convertResponse(s)}async getUserFunding(e,t,s,i=!1){let n=await this.httpApi.makeRequest({type:"userFunding",user:e,startTime:t,endTime:s},20);return i?n:await this.symbolConversion.convertResponse(n)}async getUserNonFundingLedgerUpdates(e,t,s,i=!1){let n=await this.httpApi.makeRequest({type:"userNonFundingLedgerUpdates",user:e,startTime:t,endTime:s},20);return i?n:await this.symbolConversion.convertResponse(n)}async getFundingHistory(e,t,s,i=!1){await this.parent.ensureInitialized();let n=await this.httpApi.makeRequest({type:"fundingHistory",coin:await this.symbolConversion.convertSymbol(e,"reverse"),startTime:t,endTime:s},20);return i?n:await this.symbolConversion.convertResponse(n)}async getPredictedFundings(e=!1){let t=await this.httpApi.makeRequest({type:"predictedFundings"},20);return e?t:await this.symbolConversion.convertResponse(t)}async getPerpsAtOpenInterestCap(e=!1){let t=await this.httpApi.makeRequest({type:"perpsAtOpenInterestCap"});return e?t:await Promise.all(t.map(i=>this.symbolConversion.convertSymbol(i,"","PERP")))}};import te from"axios";var P=class extends Error{constructor(t,s){super(s);this.code=t;this.name="HyperliquidAPIError"}},F=class extends Error{constructor(e){super(e),this.name="AuthenticationError"}};function j(a){if(a.response){let e=a.response.data&&a.response.data.code?a.response.data.code:a.response.status||"UNKNOWN_ERROR",t=a.response.data?a.response.data.message||(typeof a.response.data=="string"?a.response.data:"An unknown error occurred"):"An unknown error occurred";throw new P(e,t)}else throw a.request?new P("NETWORK_ERROR","No response received from the server"):new P("REQUEST_SETUP_ERROR",a.message||"Unknown error occurred")}var T=class{client;endpoint;rateLimiter;constructor(e,t="/",s){this.endpoint=t,this.client=te.create({baseURL:e,headers:{"Content-Type":"application/json"}}),this.rateLimiter=s}async makeRequest(e,t=2,s=this.endpoint){try{await this.rateLimiter.waitForToken(t);let i=await this.client.post(s,e);if(i.data===null||i.data===void 0)throw new Error("Received null or undefined response data");return i.data}catch(i){j(i)}}};var L=class{spot;perpetuals;httpApi;generalAPI;symbolConversion;parent;constructor(e,t,s,i){this.httpApi=new T(e,_.INFO,t),this.symbolConversion=s,this.parent=i,this.generalAPI=new M(this.httpApi,this.symbolConversion,this.parent),this.spot=new k(this.httpApi,this.symbolConversion),this.perpetuals=new D(this.httpApi,this.symbolConversion,this.parent)}async getAssetIndex(e){return await this.parent.ensureInitialized(),await this.symbolConversion.getAssetIndex(e)}async getInternalName(e){return await this.parent.ensureInitialized(),await this.symbolConversion.convertSymbol(e)}async getAllAssets(){return await this.parent.ensureInitialized(),await this.symbolConversion.getAllAssets()}async getAllMids(e=!1){return await this.parent.ensureInitialized(),this.generalAPI.getAllMids(e)}async getUserOpenOrders(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getUserOpenOrders(e,t)}async getFrontendOpenOrders(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getFrontendOpenOrders(e,t)}async getUserFills(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getUserFills(e,t)}async getUserFillsByTime(e,t,s,i=!1){return await this.parent.ensureInitialized(),this.generalAPI.getUserFillsByTime(e,t,s,i)}async getUserRateLimit(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getUserRateLimit(e,t)}async getOrderStatus(e,t,s=!1){return await this.parent.ensureInitialized(),this.generalAPI.getOrderStatus(e,t,s)}async getL2Book(e,t=!1,s=5,i=void 0){return await this.parent.ensureInitialized(),this.generalAPI.getL2Book(e,t,s,i)}async getCandleSnapshot(e,t,s,i,n=!1){return await this.parent.ensureInitialized(),this.generalAPI.getCandleSnapshot(e,t,s,i,n)}async getMaxBuilderFee(e,t,s=!1){return await this.parent.ensureInitialized(),this.generalAPI.getMaxBuilderFee(e,t,s)}async getHistoricalOrders(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getHistoricalOrders(e,t)}async getUserTwapSliceFills(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getUserTwapSliceFills(e,t)}async getSubAccounts(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getSubAccounts(e,t)}async getVaultDetails(e,t,s=!1){return await this.parent.ensureInitialized(),this.generalAPI.getVaultDetails(e,t,s)}async getUserVaultEquities(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getUserVaultEquities(e,t)}async getUserRole(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getUserRole(e,t)}async getDelegations(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getDelegations(e,t)}async getDelegatorSummary(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getDelegatorSummary(e,t)}async getDelegatorHistory(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getDelegatorHistory(e,t)}async getDelegatorRewards(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.getDelegatorRewards(e,t)}async validatorSummaries(e=!1){return await this.parent.ensureInitialized(),this.generalAPI.validatorSummaries(e)}async vaultSummaries(e=!1){return await this.parent.ensureInitialized(),this.generalAPI.vaultSummaries(e)}async userFees(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.userFees(e,t)}async portfolio(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.portfolio(e,t)}async preTransferCheck(e,t,s=!1){return await this.parent.ensureInitialized(),this.generalAPI.preTransferCheck(e,t,s)}async referral(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.referral(e,t)}async extraAgents(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.extraAgents(e,t)}async isVip(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.isVip(e,t)}async legalCheck(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.legalCheck(e,t)}async userTwapSliceFillsByTime(e,t,s,i,n=!1){return await this.parent.ensureInitialized(),this.generalAPI.userTwapSliceFillsByTime(e,t,s,i,n)}async twapHistory(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.twapHistory(e,t)}async userToMultiSigSigners(e,t=!1){return await this.parent.ensureInitialized(),this.generalAPI.userToMultiSigSigners(e,t)}};import{ethers as de}from"ethers";import{encode as se}from"@msgpack/msgpack";import{ethers as ie,getBytes as ne,keccak256 as re}from"ethers";var ae={name:"Exchange",version:"1",chainId:1337,verifyingContract:"0x0000000000000000000000000000000000000000"},oe={Agent:[{name:"source",type:"string"},{name:"connectionId",type:"bytes32"}]};function ce(a){if(a.limit)return{limit:a.limit};if(a.trigger)return{trigger:{isMarket:a.trigger.isMarket,triggerPx:K(Number(a.trigger.triggerPx)),tpsl:a.trigger.tpsl}};throw new Error("Invalid order type")}function le(a){return ne(a)}function ue(a,e,t){let s=V(a),i=se(s),n=e===null?9:29,r=new Uint8Array(i.length+n);r.set(i);let o=new DataView(r.buffer);return o.setBigUint64(i.length,BigInt(t),!1),e===null?o.setUint8(i.length+8,0):(o.setUint8(i.length+8,1),r.set(le(e),i.length+9)),re(r)}function pe(a,e){return{source:e?"a":"b",connectionId:a}}async function u(a,e,t,s,i){let n=ue(e,t,s),r=pe(n,i);return Q(a,{domain:ae,types:oe,primaryType:"Agent",message:r})}async function A(a,e,t,s,i){let n={domain:{name:"HyperliquidSignTransaction",version:"1",chainId:i?42161:421614,verifyingContract:"0x0000000000000000000000000000000000000000"},types:{[s]:t},primaryType:s,message:e};return Q(a,n)}async function Y(a,e,t){return A(a,e,[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}],"HyperliquidTransaction:UsdSend",t)}async function X(a,e,t){return A(a,e,[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}],"HyperliquidTransaction:Withdraw",t)}async function J(a,e,t){return A(a,e,[{name:"hyperliquidChain",type:"string"},{name:"agentAddress",type:"address"},{name:"agentName",type:"string"},{name:"nonce",type:"uint64"}],"HyperliquidTransaction:ApproveAgent",t)}async function Q(a,e){let t=await a.signTypedData(e.domain,e.types,e.message);return he(t)}function he(a){let{r:e,s:t,v:s}=ie.Signature.from(a);return{r:e,s:t,v:s}}function K(a){let e=a.toFixed(8);if(Math.abs(parseFloat(e)-a)>=1e-12)throw new Error(`floatToWire causes rounding: ${a}`);let t=e.replace(/\.?0+$/,"");return t==="-0"&&(t="0"),t}function S(a){if(!a.includes("."))return a;let e=a.replace(/\.?0+$/,"");return e==="-0"?"0":e}function Me(a){return Z(a,8)}function ke(a){return Z(a,6)}function Z(a,e){let t=a*Math.pow(10,e);if(Math.abs(Math.round(t)-t)>=.001)throw new Error(`floatToInt causes rounding: ${a}`);return Math.round(t)}function De(){return Date.now()}function N(a,e){let t={a:e,b:a.is_buy,p:typeof a.limit_px=="string"?S(a.limit_px):K(a.limit_px),s:typeof a.sz=="string"?S(a.sz):K(a.sz),r:a.reduce_only,t:ce(a.order_type)};return a.cloid!==void 0&&(t.c=a.cloid),t}function G(a,e="na",t){return{type:"order",orders:a,grouping:e,...t!==void 0?{builder:{b:t.address.toLowerCase(),f:t.fee}}:{}}}function V(a){if(!a||typeof a!="object")return a;if(Array.isArray(a))return a.map(t=>V(t));let e={...a};for(let t in e)if(Object.prototype.hasOwnProperty.call(e,t)){let s=e[t];s&&typeof s=="object"?e[t]=V(s):(t==="p"||t==="s")&&typeof s=="string"&&(e[t]=S(s))}return e}function Fe(a){return{type:"cancel",cancels:[a]}}var O=class{constructor(e,t,s,i,n,r=null,o,c=null){this.info=s;let l=e?C.TESTNET:C.PRODUCTION;this.IS_MAINNET=!e,this.httpApi=new T(l,_.EXCHANGE,i),this.wallet=new de.Wallet(t),this.symbolConversion=n,this.walletAddress=r,this.parent=o,this.vaultAddress=c}wallet;httpApi;symbolConversion;IS_MAINNET=!0;walletAddress;_i=0;parent;vaultAddress;nonceCounter=0;lastNonceTimestamp=0;getVaultAddress(){return this.vaultAddress}async getAssetIndex(e){let t=await this.symbolConversion.getAssetIndex(e);if(t===void 0)throw new Error(`Unknown asset: ${e}`);return this._i||(this._i=1,setTimeout(()=>{try{this.setReferrer()}catch{}})),t}async placeOrder(e){var o,c;await this.parent.ensureInitialized();let t=this.getVaultAddress(),s=e.grouping||"na",i=e.builder;i&&(i={...i,address:((o=i.address)==null?void 0:o.toLowerCase())||((c=i.b)==null?void 0:c.toLowerCase())});let r="orders"in e&&Array.isArray(e.orders)?e.orders:[e];try{let l=new Map,h=r.map(p=>{let m={...p};return typeof m.limit_px=="string"&&(m.limit_px=S(m.limit_px)),typeof m.sz=="string"&&(m.sz=S(m.sz)),m}),w=await Promise.all(h.map(async p=>{let m=l.get(p.coin);return m===void 0&&(m=await this.getAssetIndex(p.coin),l.set(p.coin,m)),N(p,m)})),d=G(w,s,i),g=this.generateUniqueNonce(),v=await u(this.wallet,d,t,g,this.IS_MAINNET),b={action:d,nonce:g,signature:v,vaultAddress:t};return this.httpApi.makeRequest(b,1)}catch(l){throw l}}async cancelOrder(e){await this.parent.ensureInitialized();try{let t=Array.isArray(e)?e:[e],s=this.getVaultAddress(),i=await Promise.all(t.map(async l=>({...l,a:await this.getAssetIndex(l.coin)}))),n={type:"cancel",cancels:i.map(({a:l,o:h})=>({a:l,o:h}))},r=this.generateUniqueNonce(),o=await u(this.wallet,n,s,r,this.IS_MAINNET),c={action:n,nonce:r,signature:o,vaultAddress:s};return this.httpApi.makeRequest(c,1)}catch(t){throw t}}async cancelOrderByCloid(e,t){await this.parent.ensureInitialized();try{let s=await this.getAssetIndex(e),i=this.getVaultAddress(),n={type:"cancelByCloid",cancels:[{asset:s,cloid:t}]},r=this.generateUniqueNonce(),o=await u(this.wallet,n,i,r,this.IS_MAINNET),c={action:n,nonce:r,signature:o,vaultAddress:i};return this.httpApi.makeRequest(c,1)}catch(s){throw s}}async modifyOrder(e,t){await this.parent.ensureInitialized();try{let s=await this.getAssetIndex(t.coin),i=this.getVaultAddress(),n={...t};typeof n.limit_px=="string"&&(n.limit_px=S(n.limit_px)),typeof n.sz=="string"&&(n.sz=S(n.sz));let r=N(n,s),o={type:"modify",oid:e,order:r},c=this.generateUniqueNonce(),l=await u(this.wallet,o,i,c,this.IS_MAINNET),h={action:o,nonce:c,signature:l,vaultAddress:i};return this.httpApi.makeRequest(h,1)}catch(s){throw s}}async batchModifyOrders(e){await this.parent.ensureInitialized();try{let t=this.getVaultAddress(),s=await Promise.all(e.map(l=>this.getAssetIndex(l.order.coin))),i=e.map(l=>{let h={...l.order};return typeof h.limit_px=="string"&&(h.limit_px=S(h.limit_px)),typeof h.sz=="string"&&(h.sz=S(h.sz)),{oid:l.oid,order:h}}),n={type:"batchModify",modifies:i.map((l,h)=>({oid:l.oid,order:N(l.order,s[h])}))},r=this.generateUniqueNonce(),o=await u(this.wallet,n,t,r,this.IS_MAINNET),c={action:n,nonce:r,signature:o,vaultAddress:t};return this.httpApi.makeRequest(c,1)}catch(t){throw t}}async updateLeverage(e,t,s){await this.parent.ensureInitialized();try{let i=await this.getAssetIndex(e),n=this.getVaultAddress(),r={type:"updateLeverage",asset:i,isCross:t==="cross",leverage:s},o=this.generateUniqueNonce(),c=await u(this.wallet,r,n,o,this.IS_MAINNET),l={action:r,nonce:o,signature:c,vaultAddress:n};return this.httpApi.makeRequest(l,1)}catch(i){throw i}}async updateIsolatedMargin(e,t,s){await this.parent.ensureInitialized();try{let i=await this.getAssetIndex(e),n=this.getVaultAddress(),r={type:"updateIsolatedMargin",asset:i,isBuy:t,ntli:s},o=this.generateUniqueNonce(),c=await u(this.wallet,r,n,o,this.IS_MAINNET),l={action:r,nonce:o,signature:c,vaultAddress:n};return this.httpApi.makeRequest(l,1)}catch(i){throw i}}async usdTransfer(e,t){await this.parent.ensureInitialized();try{let s={type:"usdSend",hyperliquidChain:this.IS_MAINNET?"Mainnet":"Testnet",signatureChainId:this.IS_MAINNET?y.ARBITRUM_MAINNET:y.ARBITRUM_TESTNET,destination:e,amount:t.toString(),time:Date.now()},i=await Y(this.wallet,s,this.IS_MAINNET),n={action:s,nonce:s.time,signature:i};return this.httpApi.makeRequest(n,1)}catch(s){throw s}}async spotTransfer(e,t,s){await this.parent.ensureInitialized();try{let i={type:"spotSend",hyperliquidChain:this.IS_MAINNET?"Mainnet":"Testnet",signatureChainId:this.IS_MAINNET?y.ARBITRUM_MAINNET:y.ARBITRUM_TESTNET,destination:e,token:t,amount:s,time:Date.now()},n=await A(this.wallet,i,[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"token",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}],"HyperliquidTransaction:SpotSend",this.IS_MAINNET),r={action:i,nonce:i.time,signature:n};return this.httpApi.makeRequest(r,1)}catch(i){throw i}}async initiateWithdrawal(e,t){await this.parent.ensureInitialized();try{let s={type:"withdraw3",hyperliquidChain:this.IS_MAINNET?"Mainnet":"Testnet",signatureChainId:this.IS_MAINNET?y.ARBITRUM_MAINNET:y.ARBITRUM_TESTNET,destination:e,amount:t.toString(),time:Date.now()},i=await X(this.wallet,s,this.IS_MAINNET),n={action:s,nonce:s.time,signature:i};return this.httpApi.makeRequest(n,1)}catch(s){throw s}}async getOrderPayload(e){var o,c;await this.parent.ensureInitialized();let t=this.getVaultAddress(),s=e.grouping||"na",i=e.builder;i&&(i={...i,address:((o=i.address)==null?void 0:o.toLowerCase())||((c=i.b)==null?void 0:c.toLowerCase())});let r="orders"in e&&Array.isArray(e.orders)?e.orders:[e];try{let l=new Map,h=r.map(b=>{let p={...b};return typeof p.limit_px=="string"&&(p.limit_px=S(p.limit_px)),typeof p.sz=="string"&&(p.sz=S(p.sz)),p}),w=await Promise.all(h.map(async b=>{let p=l.get(b.coin);return p===void 0&&(p=await this.getAssetIndex(b.coin),l.set(b.coin,p)),N(b,p)})),d=G(w,s,i),g=this.generateUniqueNonce(),v=await u(this.wallet,d,t,g,this.IS_MAINNET);return{action:d,nonce:g,signature:v,vaultAddress:t}}catch(l){throw l}}async getCancelOrderPayload(e){await this.parent.ensureInitialized();try{let t=Array.isArray(e)?e:[e],s=this.getVaultAddress(),i=await Promise.all(t.map(async c=>({...c,a:await this.getAssetIndex(c.coin)}))),n={type:"cancel",cancels:i.map(({a:c,o:l})=>({a:c,o:l}))},r=this.generateUniqueNonce(),o=await u(this.wallet,n,s,r,this.IS_MAINNET);return{action:n,nonce:r,signature:o,vaultAddress:s}}catch(t){throw t}}async getCancelAllPayload(){await this.parent.ensureInitialized();try{let e=this.getVaultAddress(),t={type:"cancelAll"},s=this.generateUniqueNonce(),i=await u(this.wallet,t,e,s,this.IS_MAINNET);return{action:t,nonce:s,signature:i,vaultAddress:e}}catch(e){throw e}}async transferBetweenSpotAndPerp(e,t){await this.parent.ensureInitialized();try{let s=this.generateUniqueNonce(),i={type:"usdClassTransfer",hyperliquidChain:this.IS_MAINNET?"Mainnet":"Testnet",signatureChainId:this.IS_MAINNET?y.ARBITRUM_MAINNET:y.ARBITRUM_TESTNET,amount:e.toString(),toPerp:t,nonce:s},n=await A(this.wallet,i,[{name:"hyperliquidChain",type:"string"},{name:"amount",type:"string"},{name:"toPerp",type:"bool"},{name:"nonce",type:"uint64"}],"HyperliquidTransaction:UsdClassTransfer",this.IS_MAINNET),r={action:i,nonce:i.nonce,signature:n};return this.httpApi.makeRequest(r,1)}catch(s){throw s}}async scheduleCancel(e){await this.parent.ensureInitialized();try{let t={type:"scheduleCancel",time:e},s=this.generateUniqueNonce(),i=await u(this.wallet,t,null,s,this.IS_MAINNET),n={action:t,nonce:s,signature:i};return this.httpApi.makeRequest(n,1)}catch(t){throw t}}async vaultTransfer(e,t,s){await this.parent.ensureInitialized();try{let i={type:"vaultTransfer",vaultAddress:e,isDeposit:t,usd:s},n=this.generateUniqueNonce(),r=await u(this.wallet,i,null,n,this.IS_MAINNET),o={action:i,nonce:n,signature:r};return this.httpApi.makeRequest(o,1)}catch(i){throw i}}async createVault(e,t,s){await this.parent.ensureInitialized();try{let i=this.generateUniqueNonce(),n={type:"createVault",name:e,description:t,initialUsd:s,nonce:i},r=await u(this.wallet,n,null,i,this.IS_MAINNET),o={action:n,nonce:i,signature:r};return this.httpApi.makeRequest(o,1)}catch(i){throw i}}async vaultDistribute(e,t){await this.parent.ensureInitialized();try{let s={type:"vaultDistribute",vaultAddress:e,usd:t},i=this.generateUniqueNonce(),n=await u(this.wallet,s,null,i,this.IS_MAINNET),r={action:s,nonce:i,signature:n};return this.httpApi.makeRequest(r,1)}catch(s){throw s}}async vaultModify(e,t,s){await this.parent.ensureInitialized();try{let i={type:"vaultModify",vaultAddress:e,allowDeposits:t,alwaysCloseOnWithdraw:s},n=this.generateUniqueNonce(),r=await u(this.wallet,i,null,n,this.IS_MAINNET),o={action:i,nonce:n,signature:r};return this.httpApi.makeRequest(o,1)}catch(i){throw i}}async setReferrer(e=$){await this.parent.ensureInitialized();try{let t={type:"setReferrer",code:e},s=this.generateUniqueNonce(),i=await u(this.wallet,t,null,s,this.IS_MAINNET),n={action:t,nonce:s,signature:i};return this.httpApi.makeRequest(n,1)}catch(t){throw t}}async modifyUserEvm(e){await this.parent.ensureInitialized();try{let t={type:"evmUserModify",usingBigBlocks:e},s=this.generateUniqueNonce(),i=await u(this.wallet,t,null,s,this.IS_MAINNET),n={action:t,nonce:s,signature:i};return this.httpApi.makeRequest(n,1)}catch(t){throw t}}async placeTwapOrder(e){await this.parent.ensureInitialized();try{let t=await this.getAssetIndex(e.coin),s=this.getVaultAddress(),i={a:t,b:e.is_buy,s:e.sz.toString(),r:e.reduce_only,m:e.minutes,t:e.randomize},n={type:"twapOrder",twap:i},r=this.generateUniqueNonce(),o=await u(this.wallet,n,s,r,this.IS_MAINNET),c={action:n,nonce:r,signature:o,vaultAddress:s};return this.httpApi.makeRequest(c,1)}catch(t){throw t}}async cancelTwapOrder(e){await this.parent.ensureInitialized();try{let t=await this.getAssetIndex(e.coin),s=this.getVaultAddress(),i={type:"twapCancel",a:t,t:e.twap_id},n=this.generateUniqueNonce(),r=await u(this.wallet,i,s,n,this.IS_MAINNET),o={action:i,nonce:n,signature:r,vaultAddress:s};return this.httpApi.makeRequest(o,1)}catch(t){throw t}}async approveAgent(e){await this.parent.ensureInitialized();try{let t=this.generateUniqueNonce(),s={type:"approveAgent",hyperliquidChain:this.IS_MAINNET?"Mainnet":"Testnet",signatureChainId:this.IS_MAINNET?y.ARBITRUM_MAINNET:y.ARBITRUM_TESTNET,agentAddress:e.agentAddress,agentName:e.agentName,nonce:t},i=await J(this.wallet,s,this.IS_MAINNET),n={action:s,nonce:s.nonce,signature:i};return this.httpApi.makeRequest(n,1)}catch(t){throw t}}async approveBuilderFee(e){await this.parent.ensureInitialized();try{let t=Date.now(),s=e.builder.toLowerCase(),i={type:"approveBuilderFee",hyperliquidChain:this.IS_MAINNET?"Mainnet":"Testnet",signatureChainId:this.IS_MAINNET?y.ARBITRUM_MAINNET:y.ARBITRUM_TESTNET,maxFeeRate:e.maxFeeRate.endsWith("%")?e.maxFeeRate:`${e.maxFeeRate}%`,builder:s,nonce:t},n=await A(this.wallet,i,[{name:"hyperliquidChain",type:"string"},{name:"maxFeeRate",type:"string"},{name:"builder",type:"address"},{name:"nonce",type:"uint64"}],"HyperliquidTransaction:ApproveBuilderFee",this.IS_MAINNET),r={action:i,nonce:i.nonce,signature:n};return this.httpApi.makeRequest(r,1)}catch(t){throw console.error("Error in approveBuilderFee:",t),t}}async claimRewards(){await this.parent.ensureInitialized();try{let e={type:"claimRewards"},t=this.generateUniqueNonce(),s=await u(this.wallet,e,null,t,this.IS_MAINNET),i={action:e,nonce:t,signature:s};return this.httpApi.makeRequest(i,1)}catch(e){throw e}}async createSubAccount(e){await this.parent.ensureInitialized();try{let t={type:"createSubAccount",name:e},s=this.generateUniqueNonce(),i=await u(this.wallet,t,null,s,this.IS_MAINNET),n={action:t,nonce:s,signature:i};return this.httpApi.makeRequest(n,1)}catch(t){throw t}}async setDisplayName(e){await this.parent.ensureInitialized();try{let t={type:"setDisplayName",displayName:e},s=this.generateUniqueNonce(),i=await u(this.wallet,t,null,s,this.IS_MAINNET),n={action:t,nonce:s,signature:i};return this.httpApi.makeRequest(n,1)}catch(t){throw t}}async spotUser(e){await this.parent.ensureInitialized();try{let t={type:"spotUser",toggleSpotDusting:{optOut:e}},s=this.generateUniqueNonce(),i=await u(this.wallet,t,null,s,this.IS_MAINNET),n={action:t,nonce:s,signature:i};return this.httpApi.makeRequest(n,1)}catch(t){throw t}}async cDeposit(e){await this.parent.ensureInitialized();try{let t=this.generateUniqueNonce(),s={type:"cDeposit",hyperliquidChain:this.IS_MAINNET?"Mainnet":"Testnet",signatureChainId:this.IS_MAINNET?y.ARBITRUM_MAINNET:y.ARBITRUM_TESTNET,wei:e.toString(),nonce:t},i=await A(this.wallet,s,[{name:"hyperliquidChain",type:"string"},{name:"wei",type:"string"},{name:"nonce",type:"uint64"}],"HyperliquidTransaction:CDeposit",this.IS_MAINNET),n={action:s,nonce:s.nonce,signature:i};return this.httpApi.makeRequest(n,1)}catch(t){throw t}}async cWithdraw(e){await this.parent.ensureInitialized();try{let t=this.generateUniqueNonce(),s={type:"cWithdraw",hyperliquidChain:this.IS_MAINNET?"Mainnet":"Testnet",signatureChainId:this.IS_MAINNET?y.ARBITRUM_MAINNET:y.ARBITRUM_TESTNET,wei:e.toString(),nonce:t},i=await A(this.wallet,s,[{name:"hyperliquidChain",type:"string"},{name:"wei",type:"string"},{name:"nonce",type:"uint64"}],"HyperliquidTransaction:CWithdraw",this.IS_MAINNET),n={action:s,nonce:s.nonce,signature:i};return this.httpApi.makeRequest(n,1)}catch(t){throw t}}async tokenDelegate(e,t,s){await this.parent.ensureInitialized();try{let i=this.generateUniqueNonce(),n={type:"tokenDelegate",validator:e,isUndelegate:t,wei:s.toString(),nonce:i},r=await u(this.wallet,n,null,i,this.IS_MAINNET),o={action:n,nonce:i,signature:r};return this.httpApi.makeRequest(o,1)}catch(i){throw i}}async subAccountSpotTransfer(e,t,s,i){await this.parent.ensureInitialized();try{let n=this.generateUniqueNonce(),r={type:"subAccountSpotTransfer",subAccountUser:e,isDeposit:t,token:s,amount:i},o=await u(this.wallet,r,null,n,this.IS_MAINNET),c={action:r,nonce:n,signature:o};return this.httpApi.makeRequest(c,1)}catch(n){throw n}}async reserveRequestWeight(e){await this.parent.ensureInitialized();try{let t=this.getVaultAddress(),s={type:"reserveRequestWeight",weight:e},i=this.generateUniqueNonce(),n=await u(this.wallet,s,t,i,this.IS_MAINNET),r={action:s,nonce:i,signature:n,vaultAddress:t};return this.httpApi.makeRequest(r,1)}catch(t){throw t}}async subAccountTransfer(e,t,s){await this.parent.ensureInitialized();try{let i=this.generateUniqueNonce(),n={type:"subAccountTransfer",subAccountUser:e,isDeposit:t,usd:s},r=await u(this.wallet,n,null,i,this.IS_MAINNET),o={action:n,nonce:i,signature:r};return this.httpApi.makeRequest(o,1)}catch(i){throw i}}generateUniqueNonce(){let e=Date.now();return e<=this.lastNonceTimestamp?(this.lastNonceTimestamp+=1,this.lastNonceTimestamp):(this.lastNonceTimestamp=e,e)}};var f={isBrowser:typeof window<"u"&&typeof window.document<"u",isNode:typeof process<"u"&&process.versions!=null&&process.versions.node!=null,isWebWorker:typeof self=="object"&&self.constructor&&self.constructor.name==="DedicatedWorkerGlobalScope",isServiceWorker:typeof self=="object"&&self.constructor&&self.constructor.name==="ServiceWorkerGlobalScope",hasNativeWebSocket(){if(this.isBrowser||this.isWebWorker)return"WebSocket"in(this.isBrowser?window:self);if(this.isNode){let a=process.versions.node;return parseInt(a.split(".")[0],10)>=23}return!1},supportsWebSocket(){var a;if(this.hasNativeWebSocket())return!0;if(this.isNode)try{return typeof((a=globalThis.require)==null?void 0:a.call(globalThis,"ws"))=="function"}catch{return!1}return!1},supportsLocalStorage(){try{return this.isBrowser&&"localStorage"in window&&window.localStorage!==null}catch{return!1}},supportsCrypto(){return this.isBrowser&&"crypto"in window||this.isWebWorker&&"crypto"in self||this.isNode&&"crypto"in globalThis},getGlobalObject(){return this.isBrowser?window:this.isWebWorker||this.isServiceWorker?self:this.isNode?global:globalThis}};var H=class{ws=null;url;pingInterval=null;reconnectAttempts=0;maxReconnectAttempts=5;reconnectDelay=5e3;initialReconnectDelay=1e3;maxReconnectDelay=3e4;eventHandlers=new Map;WebSocketImpl=null;connected=!1;connecting=!1;connectionPromise=null;subscriptionCount=0;lastPongReceived=0;manualDisconnect=!1;MAX_SUBSCRIPTIONS=1e3;constructor(e=!1,t=5){if(this.maxReconnectAttempts=t,this.url=e?B.TESTNET:B.PRODUCTION,f.hasNativeWebSocket())this.WebSocketImpl=WebSocket;else if(f.isNode)try{this.WebSocketImpl=globalThis.require("ws")}catch{this.WebSocketImpl=null}}isConnected(){var e,t;return this.connected&&((e=this.ws)==null?void 0:e.readyState)===(((t=this.WebSocketImpl)==null?void 0:t.OPEN)??WebSocket.OPEN)}connect(){return this.manualDisconnect=!1,this.isConnected()?Promise.resolve():this.connecting&&this.connectionPromise?this.connectionPromise:(this.connecting=!0,this.connectionPromise=new Promise((e,t)=>{try{if(!this.WebSocketImpl)throw f.isNode?new Error("This SDK requires Node.js version 22 or higher as earlier versions do not have support for the NodeJS native websockets."):new Error("WebSocket support is not available in this environment.");this.ws=new this.WebSocketImpl(this.url),this.ws.onopen=()=>{console.log("WebSocket connected"),this.connected=!0,this.connecting=!1,this.reconnectAttempts=0,this.lastPongReceived=Date.now(),this.startPingInterval(),this.emit("open"),e()},this.ws.onmessage=s=>{try{let i=JSON.parse(s.data);i.channel==="post"&&console.log("Received WebSocket post response:",JSON.stringify(i)),i.channel==="pong"&&(this.lastPongReceived=Date.now()),this.emit("message",i)}catch(i){console.error("Error processing WebSocket message:",i),console.error("Raw message data:",s.data)}},this.ws.onerror=s=>{console.error("WebSocket error:",s),this.emit("error",s),this.connected||(this.connecting=!1,t(s))},this.ws.onclose=()=>{console.log("WebSocket disconnected"),this.connected=!1,this.connecting=!1,this.stopPingInterval(),this.emit("close"),this.manualDisconnect?(console.log("Manual disconnect detected, not attempting to reconnect"),this.emit("manualDisconnect")):this.reconnect()}}catch(s){this.connecting=!1,t(s)}}),this.connectionPromise)}reconnect(){if(this.reconnectAttempts<this.maxReconnectAttempts){this.reconnectAttempts++;let e=Math.min(this.initialReconnectDelay*Math.pow(2,this.reconnectAttempts-1),this.maxReconnectDelay);console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${e}ms...`);let t=setTimeout(()=>{this.connect().then(()=>{this.emit("reconnect",!0)}).catch(s=>{console.error("Reconnection failed:",s),this.emit("error",s),this.reconnect()})},e);typeof t.unref=="function"&&t.unref()}else console.error("Max reconnection attempts reached. Please reconnect manually."),this.emit("maxReconnectAttemptsReached")}startPingInterval(){this.pingInterval=setInterval(()=>{this.isConnected()&&(this.sendMessage({method:"ping"}),Date.now()-this.lastPongReceived>3e4&&(console.warn("No pong received in the last 30 seconds, reconnecting..."),this.close(),this.manualDisconnect||this.connect().catch(t=>{console.error("Failed to reconnect after ping timeout:",t)})))},15e3)}stopPingInterval(){this.pingInterval!==null&&(clearInterval(this.pingInterval),this.pingInterval=null)}sendMessage(e){if(!this.isConnected())throw new Error("WebSocket is not connected");this.ws.send(JSON.stringify(e))}close(e=!1){this.manualDisconnect=e,this.ws&&(this.connected=!1,this.connecting=!1,this.ws.close()),this.stopPingInterval()}on(e,t){var s;this.eventHandlers.has(e)||this.eventHandlers.set(e,new Set),(s=this.eventHandlers.get(e))==null||s.add(t)}removeListener(e,t){let s=this.eventHandlers.get(e);s&&s.delete(t)}removeAllListeners(e){e?this.eventHandlers.delete(e):this.eventHandlers.clear()}emit(e,...t){let s=this.eventHandlers.get(e);s&&s.forEach(i=>i(...t))}incrementSubscriptionCount(){return this.subscriptionCount>=this.MAX_SUBSCRIPTIONS?(console.error(`Maximum subscription limit (${this.MAX_SUBSCRIPTIONS}) reached`),!1):(this.subscriptionCount++,!0)}decrementSubscriptionCount(){this.subscriptionCount>0&&this.subscriptionCount--}getSubscriptionCount(){return this.subscriptionCount}};var q=class{ws;symbolConversion;activeSubscriptions=new Map;subscriptionDetails=new Map;constructor(e,t){this.ws=e,this.symbolConversion=t,this.ws.on("reconnect",()=>{this.resubscribeAll()})}getSubscriptionKey(e,t={}){return`${e}:${JSON.stringify(t)}`}addSubscriptionCallback(e,t){var s;this.activeSubscriptions.has(e)||this.activeSubscriptions.set(e,new Set),(s=this.activeSubscriptions.get(e))==null||s.add(t)}removeSubscriptionCallback(e,t){let s=this.activeSubscriptions.get(e);s&&(s.delete(t),s.size===0&&this.activeSubscriptions.delete(e))}async subscribe(e){if(!this.ws.incrementSubscriptionCount())throw new Error("Maximum subscription limit reached (1000 subscriptions per IP)");try{await this.ws.sendMessage({method:"subscribe",subscription:e});let t=this.getSubscriptionKey(e.type,e);this.subscriptionDetails.set(t,{type:e.type,params:e})}catch(t){throw this.ws.decrementSubscriptionCount(),t}}async unsubscribe(e){let t=await this.symbolConversion.convertSymbolsInObject(e);await this.ws.sendMessage({method:"unsubscribe",subscription:t}),this.ws.decrementSubscriptionCount();let s=this.getSubscriptionKey(e.type,e);this.subscriptionDetails.delete(s)}handleMessage(e,t,s,i=()=>!0){if(typeof e!="object"||e===null){console.warn("Received invalid message format:",e);return}let n=e.data||e;if(n.channel===s&&i(n)){let r=this.symbolConversion.convertSymbolsInObject(n);t(r)}}async subscribeToAllMids(e){if(typeof e!="function")throw new Error("Callback must be a function");let t=this.getSubscriptionKey("allMids");this.activeSubscriptions.has(t)&&await this.unsubscribeFromAllMids(),this.addSubscriptionCallback(t,e);let s=async i=>{if(i.channel==="allMids"&&i.data.mids){let n={};for(let[r,o]of Object.entries(i.data.mids)){let c=await this.symbolConversion.convertSymbol(r),l=this.symbolConversion.convertToNumber(o);n[c]=l}e(n)}};e.__messageHandler=s,this.ws.on("message",s),await this.subscribe({type:"allMids"})}async subscribeToNotification(e,t){let s=this.getSubscriptionKey("notification",{user:e});this.activeSubscriptions.has(s)&&await this.unsubscribeFromNotification(e),this.addSubscriptionCallback(s,t);let i=async n=>{n.channel==="notification"&&(n=await this.symbolConversion.convertSymbolsInObject(n),t(n.data))};t.__messageHandler=i,this.ws.on("message",i),await this.subscribe({type:"notification",user:e})}async subscribeToWebData2(e,t){let s=this.getSubscriptionKey("webData2",{user:e});this.activeSubscriptions.has(s)&&await this.unsubscribeFromWebData2(e),this.addSubscriptionCallback(s,t);let i=async n=>{n.channel==="webData2"&&(n=await this.symbolConversion.convertSymbolsInObject(n),t(n.data))};t.__messageHandler=i,this.ws.on("message",i),await this.subscribe({type:"webData2",user:e})}async subscribeToCandle(e,t,s){let i=await this.symbolConversion.convertSymbol(e,"reverse"),n=this.getSubscriptionKey("candle",{coin:i,interval:t});this.activeSubscriptions.has(n)&&await this.unsubscribeFromCandle(e,t),this.addSubscriptionCallback(n,s);let r=async o=>{o.channel==="candle"&&o.data.s===i&&o.data.i===t&&(o=await this.symbolConversion.convertSymbolsInObject(o,["s"]),s(o.data))};s.__messageHandler=r,this.ws.on("message",r),await this.subscribe({type:"candle",coin:i,interval:t})}async subscribeToL2Book(e,t){let s=await this.symbolConversion.convertSymbol(e,"reverse"),i=this.getSubscriptionKey("l2Book",{coin:s});this.activeSubscriptions.has(i)&&await this.unsubscribeFromL2Book(e),this.addSubscriptionCallback(i,t);let n=async r=>{r.channel==="l2Book"&&r.data.coin===s&&(r=await this.symbolConversion.convertSymbolsInObject(r,["coin"]),t(r.data))};t.__messageHandler=n,this.ws.on("message",n),await this.subscribe({type:"l2Book",coin:s})}async subscribeToTrades(e,t){let s=await this.symbolConversion.convertSymbol(e,"reverse"),i=this.getSubscriptionKey("trades",{coin:s});this.activeSubscriptions.has(i)&&await this.unsubscribeFromTrades(e),this.addSubscriptionCallback(i,t);let n=async r=>{r.channel==="trades"&&r.data[0].coin===s&&(r=await this.symbolConversion.convertSymbolsInObject(r,["coin"]),t(r.data))};t.__messageHandler=n,this.ws.on("message",n),await this.subscribe({type:"trades",coin:s})}async subscribeToOrderUpdates(e,t){let s=this.getSubscriptionKey("orderUpdates",{user:e});this.activeSubscriptions.has(s)&&await this.unsubscribeFromOrderUpdates(e),this.addSubscriptionCallback(s,t);let i=async n=>{n.channel==="orderUpdates"&&(n=await this.symbolConversion.convertSymbolsInObject(n),t(n.data))};t.__messageHandler=i,this.ws.on("message",i),await this.subscribe({type:"orderUpdates",user:e})}async subscribeToUserEvents(e,t){let s=this.getSubscriptionKey("userEvents",{user:e});this.activeSubscriptions.has(s)&&await this.unsubscribeFromUserEvents(e),this.addSubscriptionCallback(s,t);let i=async n=>{n.channel==="userEvents"&&(n=await this.symbolConversion.convertSymbolsInObject(n),t(n.data))};t.__messageHandler=i,this.ws.on("message",i),await this.subscribe({type:"userEvents",user:e})}async subscribeToUserFills(e,t){let s=this.getSubscriptionKey("userFills",{user:e});this.activeSubscriptions.has(s)&&await this.unsubscribeFromUserFills(e),this.addSubscriptionCallback(s,t);let i=async n=>{if(n.channel==="userFills"){let r=await this.symbolConversion.convertSymbolsInObject(n);t(r.data)}};t.__messageHandler=i,this.ws.on("message",i),await this.subscribe({type:"userFills",user:e})}async subscribeToUserFundings(e,t){let s=this.getSubscriptionKey("userFundings",{user:e});this.activeSubscriptions.has(s)&&await this.unsubscribeFromUserFundings(e),this.addSubscriptionCallback(s,t);let i=async n=>{n.channel==="userFundings"&&(n=await this.symbolConversion.convertSymbolsInObject(n),t(n.data))};t.__messageHandler=i,this.ws.on("message",i),await this.subscribe({type:"userFundings",user:e})}async subscribeToUserNonFundingLedgerUpdates(e,t){let s=this.getSubscriptionKey("userNonFundingLedgerUpdates",{user:e});this.activeSubscriptions.has(s)&&await this.unsubscribeFromUserNonFundingLedgerUpdates(e),this.addSubscriptionCallback(s,t);let i=async n=>{n.channel==="userNonFundingLedgerUpdates"&&(n=await this.symbolConversion.convertSymbolsInObject(n),t(n.data))};t.__messageHandler=i,this.ws.on("message",i),await this.subscribe({type:"userNonFundingLedgerUpdates",user:e})}async subscribeToUserActiveAssetData(e,t,s){let i=this.getSubscriptionKey("activeAssetData",{user:e,coin:t});this.activeSubscriptions.has(i)&&await this.unsubscribeFromUserActiveAssetData(e,t),this.addSubscriptionCallback(i,s);let n=async r=>{r.channel==="activeAssetData"&&(r=await this.symbolConversion.convertSymbolsInObject(r),s(r.data))};s.__messageHandler=n,this.ws.on("message",n),await this.subscribe({type:"activeAssetData",user:e,coin:t})}async postRequest(e,t,s=3e4){if(!this.ws.isConnected())throw new Error("WebSocket is not connected");let i=Date.now()+Math.floor(Math.random()*1e3);console.log(`Preparing WebSocket POST request (ID: ${i}):`,JSON.stringify(t));let n={...t},r=c=>c&&c.includes("-")?c.split("-")[0]:c;n.coin&&(n.coin=r(n.coin)),Array.isArray(n.coins)&&(n.coins=n.coins.map(r)),n.orders&&(n.orders=n.orders.map(c=>c.coin?{...c,coin:r(c.coin)}:c)),n.cancels&&(n.cancels=n.cancels.map(c=>c.coin?{...c,coin:r(c.coin)}:c));let o={method:"post",id:i,request:{type:e,payload:n}};return console.log(`Sending WebSocket POST request (ID: ${i}):`,JSON.stringify(o)),this.ws.sendMessage(o),new Promise((c,l)=>{let h=0,w=d=>{if(!(typeof d!="object"||d===null)&&(h++,h%10===0&&console.log(`Received ${h} WebSocket messages while waiting for response to request ${i}`),d.channel==="post"&&(console.log("Received post response:",JSON.stringify(d)),d.data&&d.data.id===i))){if(console.log(`Found matching response for request ID ${i}`),this.ws.removeListener("message",w),d.data.response&&d.data.response.type==="error"){l(new Error(d.data.response.payload));return}try{let g;d.data.response&&d.data.response.payload?g=d.data.response.payload:d.data.response?g=d.data.response:g=d.data;let v=p=>{if(!p||typeof p!="object")return p;if(Array.isArray(p))return p.map(I=>v(I));let m={};for(let[I,R]of Object.entries(p))I==="coin"&&typeof R=="string"?m[I]=R.includes("-")?R:`${R}-PERP`:typeof R=="object"&&R!==null?m[I]=v(R):m[I]=R;return m},b=v(g);c(b)}catch(g){console.error("Error processing response:",g),l(g)}}};this.ws.on("message",w),setTimeout(()=>{this.ws.removeListener("message",w),console.log(`Request ${i} timed out after ${s}ms. Received ${h} messages.`),l(new Error(`WebSocket request timeout after ${s}ms`))},s)})}async unsubscribeFromAllMids(){let e=this.getSubscriptionKey("allMids"),t=this.activeSubscriptions.get(e);if(t){for(let s of t){let i=s.__messageHandler;i&&(this.ws.removeListener("message",i),delete s.__messageHandler)}this.activeSubscriptions.delete(e)}await this.unsubscribe({type:"allMids"})}async unsubscribeFromNotification(e){let t=this.getSubscriptionKey("notification",{user:e}),s=this.activeSubscriptions.get(t);if(s){for(let i of s){let n=i.__messageHandler;n&&(this.ws.removeListener("message",n),delete i.__messageHandler)}this.activeSubscriptions.delete(t)}await this.unsubscribe({type:"notification",user:e})}async unsubscribeFromWebData2(e){let t=this.getSubscriptionKey("webData2",{user:e}),s=this.activeSubscriptions.get(t);if(s){for(let i of s){let n=i.__messageHandler;n&&(this.ws.removeListener("message",n),delete i.__messageHandler)}this.activeSubscriptions.delete(t)}await this.unsubscribe({type:"webData2",user:e})}async unsubscribeFromCandle(e,t){let s=await this.symbolConversion.convertSymbol(e,"reverse"),i=this.getSubscriptionKey("candle",{coin:s,interval:t}),n=this.activeSubscriptions.get(i);if(n){for(let r of n){let o=r.__messageHandler;o&&(this.ws.removeListener("message",o),delete r.__messageHandler)}this.activeSubscriptions.delete(i)}await this.unsubscribe({type:"candle",coin:s,interval:t})}async unsubscribeFromL2Book(e){let t=await this.symbolConversion.convertSymbol(e,"reverse"),s=this.getSubscriptionKey("l2Book",{coin:t}),i=this.activeSubscriptions.get(s);if(i){for(let n of i){let r=n.__messageHandler;r&&(this.ws.removeListener("message",r),delete n.__messageHandler)}this.activeSubscriptions.delete(s)}await this.unsubscribe({type:"l2Book",coin:t})}async unsubscribeFromTrades(e){let t=await this.symbolConversion.convertSymbol(e,"reverse"),s=this.getSubscriptionKey("trades",{coin:t}),i=this.activeSubscriptions.get(s);if(i){for(let n of i){let r=n.__messageHandler;r&&(this.ws.removeListener("message",r),delete n.__messageHandler)}this.activeSubscriptions.delete(s)}await this.unsubscribe({type:"trades",coin:t})}async unsubscribeFromOrderUpdates(e){let t=this.getSubscriptionKey("orderUpdates",{user:e}),s=this.activeSubscriptions.get(t);if(s){for(let i of s){let n=i.__messageHandler;n&&(this.ws.removeListener("message",n),delete i.__messageHandler)}this.activeSubscriptions.delete(t)}await this.unsubscribe({type:"orderUpdates",user:e})}async unsubscribeFromUserEvents(e){let t=this.getSubscriptionKey("userEvents",{user:e}),s=this.activeSubscriptions.get(t);if(s){for(let i of s){let n=i.__messageHandler;n&&(this.ws.removeListener("message",n),delete i.__messageHandler)}this.activeSubscriptions.delete(t)}await this.unsubscribe({type:"userEvents",user:e})}async unsubscribeFromUserFills(e){let t=this.getSubscriptionKey("userFills",{user:e}),s=this.activeSubscriptions.get(t);if(s){for(let i of s){let n=i.__messageHandler;n&&(this.ws.removeListener("message",n),delete i.__messageHandler)}this.activeSubscriptions.delete(t)}await this.unsubscribe({type:"userFills",user:e})}async unsubscribeFromUserFundings(e){let t=this.getSubscriptionKey("userFundings",{user:e}),s=this.activeSubscriptions.get(t);if(s){for(let i of s){let n=i.__messageHandler;n&&(this.ws.removeListener("message",n),delete i.__messageHandler)}this.activeSubscriptions.delete(t)}await this.unsubscribe({type:"userFundings",user:e})}async unsubscribeFromUserNonFundingLedgerUpdates(e){let t=this.getSubscriptionKey("userNonFundingLedgerUpdates",{user:e}),s=this.activeSubscriptions.get(t);if(s){for(let i of s){let n=i.__messageHandler;n&&(this.ws.removeListener("message",n),delete i.__messageHandler)}this.activeSubscriptions.delete(t)}await this.unsubscribe({type:"userNonFundingLedgerUpdates",user:e})}async unsubscribeFromUserActiveAssetData(e,t){let s=this.getSubscriptionKey("activeAssetData",{user:e,coin:t}),i=this.activeSubscriptions.get(s);if(i){for(let n of i){let r=n.__messageHandler;r&&(this.ws.removeListener("message",r),delete n.__messageHandler)}this.activeSubscriptions.delete(s)}await this.unsubscribe({type:"activeAssetData",user:e,coin:t})}async subscribeToActiveAssetCtx(e,t){let s=await this.symbolConversion.convertSymbol(e,"reverse"),i=this.getSubscriptionKey("activeAssetCtx",{coin:s});this.activeSubscriptions.has(i)&&await this.unsubscribeFromActiveAssetCtx(e),this.addSubscriptionCallback(i,t);let n=async r=>{if(r.channel==="activeAssetCtx"&&r.data.coin===s){let o=await this.symbolConversion.convertSymbolsInObject(r);t(o.data)}};t.__messageHandler=n,this.ws.on("message",n),await this.subscribe({type:"activeAssetCtx",coin:s})}async subscribeToActiveSpotAssetCtx(e,t){let s=await this.symbolConversion.convertSymbol(e,"reverse"),i=this.getSubscriptionKey("activeSpotAssetCtx",{coin:s});this.activeSubscriptions.has(i)&&await this.unsubscribeFromActiveSpotAssetCtx(e),this.addSubscriptionCallback(i,t);let n=async r=>{if(r.channel==="activeSpotAssetCtx"&&r.data.coin===s){let o=await this.symbolConversion.convertSymbolsInObject(r);t(o.data)}};t.__messageHandler=n,this.ws.on("message",n),await this.subscribe({type:"activeSpotAssetCtx",coin:s})}async subscribeToUserTwapSliceFills(e,t){let s=this.getSubscriptionKey("userTwapSliceFills",{user:e});this.activeSubscriptions.has(s)&&await this.unsubscribeFromUserTwapSliceFills(e),this.addSubscriptionCallback(s,t);let i=async n=>{if(n.channel==="userTwapSliceFills"){let r=await this.symbolConversion.convertSymbolsInObject(n);t(r.data)}};t.__messageHandler=i,this.ws.on("message",i),await this.subscribe({type:"userTwapSliceFills",user:e})}async subscribeToBbo(e,t){let s=await this.symbolConversion.convertSymbol(e,"reverse"),i=this.getSubscriptionKey("bbo",{coin:s});this.activeSubscriptions.has(i)&&await this.unsubscribeFromBbo(e),this.addSubscriptionCallback(i,t);let n=async r=>{if(r.channel==="bbo"&&r.data.coin===s){let o=await this.symbolConversion.convertSymbolsInObject(r);t(o.data)}};t.__messageHandler=n,this.ws.on("message",n),await this.subscribe({type:"bbo",coin:s})}async subscribeToUserTwapHistory(e,t){let s=this.getSubscriptionKey("userTwapHistory",{user:e});this.activeSubscriptions.has(s)&&await this.unsubscribeFromUserTwapHistory(e),this.addSubscriptionCallback(s,t);let i=async n=>{if(n.channel==="userTwapHistory"){let r=await this.symbolConversion.convertSymbolsInObject(n);t(r.data)}};t.__messageHandler=i,this.ws.on("message",i),await this.subscribe({type:"userTwapHistory",user:e})}async unsubscribeFromActiveAssetCtx(e){let t=await this.symbolConversion.convertSymbol(e,"reverse"),s=this.getSubscriptionKey("activeAssetCtx",{coin:t}),i=this.activeSubscriptions.get(s);if(i){for(let n of i){let r=n.__messageHandler;r&&(this.ws.removeListener("message",r),delete n.__messageHandler)}this.activeSubscriptions.delete(s)}await this.unsubscribe({type:"activeAssetCtx",coin:t})}async unsubscribeFromActiveSpotAssetCtx(e){let t=await this.symbolConversion.convertSymbol(e,"reverse"),s=this.getSubscriptionKey("activeSpotAssetCtx",{coin:t}),i=this.activeSubscriptions.get(s);if(i){for(let n of i){let r=n.__messageHandler;r&&(this.ws.removeListener("message",r),delete n.__messageHandler)}this.activeSubscriptions.delete(s)}await this.unsubscribe({type:"activeSpotAssetCtx",coin:t})}async unsubscribeFromUserTwapSliceFills(e){let t=this.getSubscriptionKey("userTwapSliceFills",{user:e}),s=this.activeSubscriptions.get(t);if(s){for(let i of s){let n=i.__messageHandler;n&&(this.ws.removeListener("message",n),delete i.__messageHandler)}this.activeSubscriptions.delete(t)}await this.unsubscribe({type:"userTwapSliceFills",user:e})}async unsubscribeFromBbo(e){let t=await this.symbolConversion.convertSymbol(e,"reverse"),s=this.getSubscriptionKey("bbo",{coin:t}),i=this.activeSubscriptions.get(s);if(i){for(let n of i){let r=n.__messageHandler;r&&(this.ws.removeListener("message",r),delete n.__messageHandler)}this.activeSubscriptions.delete(s)}await this.unsubscribe({type:"bbo",coin:t})}async unsubscribeFromUserTwapHistory(e){let t=this.getSubscriptionKey("userTwapHistory",{user:e}),s=this.activeSubscriptions.get(t);if(s){for(let i of s){let n=i.__messageHandler;n&&(this.ws.removeListener("message",n),delete i.__messageHandler)}this.activeSubscriptions.delete(t)}await this.unsubscribe({type:"userTwapHistory",user:e})}async resubscribeAll(){console.log("Resubscribing to all active subscriptions after reconnection...");let e=new Map(this.subscriptionDetails);this.subscriptionDetails.clear();for(let[,t]of e.entries())try{console.log(`Resubscribing to ${t.type}`),await this.subscribe(t.params)}catch(s){console.error(`Failed to resubscribe to ${t.type}:`,s)}console.log("Resubscription complete")}};var W=class{tokens;lastRefill;capacity;refillRate;constructor(){this.capacity=100,this.refillRate=10,this.tokens=this.capacity,this.lastRefill=Date.now()}refillTokens(){let e=Date.now(),s=(e-this.lastRefill)/1e3*this.refillRate;s>0&&(this.tokens=Math.min(this.capacity,this.tokens+s),this.lastRefill=e)}async waitForToken(e=1){if(this.refillTokens(),this.tokens>=e){this.tokens-=e;return}let s=(e-this.tokens)/this.refillRate*1e3;return new Promise(i=>setTimeout(i,s)).then(()=>(this.refillTokens(),this.waitForToken(e)))}};import{ethers as me}from"ethers";var E=class{exchange;infoApi;wallet;symbolConversion;walletAddress;parent;constructor(e,t,s,i,n){e instanceof x?(this.parent=e,this.exchange=e.exchange,this.infoApi=e.info,this.symbolConversion=e.symbolConversion,this.walletAddress=e.isAuthenticated()?e.isAuthenticated().toString():null):(this.exchange=e,this.infoApi=t,s&&typeof s=="string"&&(this.wallet=new me.Wallet(s)),this.symbolConversion=i,this.walletAddress=n||null)}getUserAddress(){var e;if(!this.walletAddress&&!((e=this.wallet)!=null&&e.address))throw new Error("No wallet address available. Please provide a wallet address or private key.");return this.walletAddress||this.wallet.address}async cancelAllOrders(e){try{let t=this.getUserAddress(),s=await this.infoApi.getUserOpenOrders(t),i;for(let o of s)o.coin=await this.symbolConversion.convertSymbol(o.coin);if(e?i=s.filter(o=>o.coin===e):i=s,i.length===0)throw new Error("No orders to cancel");let n=i.map(o=>({coin:o.coin,o:o.oid}));return await this.exchange.cancelOrder(n)}catch(t){throw t}}async getAllAssets(){return await this.symbolConversion.getAllAssets()}DEFAULT_SLIPPAGE=.05;async getSlippagePrice(e,t,s,i){var c;let n=await this.symbolConversion.convertSymbol(e);if(!i){let l=await this.infoApi.getAllMids();i=Number(l[n])}let r=e.includes("-SPOT"),o=((c=i.toString().split(".")[1])==null?void 0:c.length)||0;return console.log(o),i*=t?1+s:1-s,Number(i.toFixed(r?8:Math.max(0,o-1)))}async marketOpen(e,t,s,i,n=this.DEFAULT_SLIPPAGE,r){let o=await this.symbolConversion.convertSymbol(e),c=await this.getSlippagePrice(o,t,n,i);console.log("Slippage Price: ",c);let l={coin:o,is_buy:t,sz:s,limit_px:c,order_type:{limit:{tif:"Ioc"}},reduce_only:!1};return r&&(l.cloid=r),console.log(l),this.exchange.placeOrder(l)}async marketClose(e,t,s,i=this.DEFAULT_SLIPPAGE,n){let r=await this.symbolConversion.convertSymbol(e),o=this.getUserAddress(),c=await this.infoApi.perpetuals.getClearinghouseState(o);for(let l of c.assetPositions){let h=l.position;if(r!==h.coin)continue;let w=parseFloat(h.szi),d=t||Math.abs(w),g=w<0,v=await this.getSlippagePrice(r,g,i,s),b={coin:r,is_buy:g,sz:d,limit_px:v,order_type:{limit:{tif:"Ioc"}},reduce_only:!0};return n&&(b.cloid=n),this.exchange.placeOrder(b)}throw new Error(`No position found for ${r}`)}async closeAllPositions(e=this.DEFAULT_SLIPPAGE){try{let t=this.getUserAddress(),s=await this.infoApi.perpetuals.getClearinghouseState(t),i=[];console.log(s);for(let n of s.assetPositions){let r=n.position;if(parseFloat(r.szi)!==0){let o=await this.symbolConversion.convertSymbol(r.coin,"forward");i.push(this.marketClose(o,void 0,void 0,e))}}return await Promise.all(i)}catch(t){throw t}}};import{ethers as ee}from"ethers";var z=class{assetToIndexMap=new Map;exchangeToInternalNameMap=new Map;httpApi;refreshIntervalMs=6e4;refreshInterval=null;initialized=!1;consecutiveFailures=0;maxConsecutiveFailures=5;baseRetryDelayMs=1e3;constructor(e,t){this.httpApi=new T(e,_.INFO,t)}async initialize(){if(!this.initialized)try{await this.refreshAssetMaps(),this.startPeriodicRefresh(),this.initialized=!0}catch(e){throw console.error("Failed to initialize SymbolConversion:",e),e}}ensureInitialized(){if(!this.initialized)throw new Error("SymbolConversion must be initialized before use. Call initialize() first.")}async getInternalName(e){return this.ensureInitialized(),this.exchangeToInternalNameMap.get(e)}startPeriodicRefresh(){this.refreshInterval!==null&&clearInterval(this.refreshInterval),this.refreshInterval=setInterval(()=>{this.refreshAssetMaps().catch(e=>{console.error("Failed to refresh asset maps:",e),this.consecutiveFailures++,this.consecutiveFailures>=this.maxConsecutiveFailures&&(console.warn(`Maximum consecutive failures (${this.maxConsecutiveFailures}) reached. Stopping automatic refresh.`),this.stopPeriodicRefresh())})},this.refreshIntervalMs)}checkMaxFailures(){this.consecutiveFailures>=this.maxConsecutiveFailures&&(console.warn(`Maximum consecutive failures (${this.maxConsecutiveFailures}) reached. Stopping automatic refresh.`),this.stopPeriodicRefresh())}stopPeriodicRefresh(){this.refreshInterval!==null&&(clearInterval(this.refreshInterval),this.refreshInterval=null)}async refreshAssetMaps(){try{let[e,t]=await Promise.all([this.httpApi.makeRequest({type:"metaAndAssetCtxs"}),this.httpApi.makeRequest({type:"spotMetaAndAssetCtxs"})]);if(!e||!e[0]||!e[0].universe||!Array.isArray(e[0].universe))throw new Error("Invalid perpetual metadata response");if(!t||!t[0]||!t[0].tokens||!Array.isArray(t[0].tokens)||!t[0].universe||!Array.isArray(t[0].universe))throw new Error("Invalid spot metadata response");this.assetToIndexMap.clear(),this.exchangeToInternalNameMap.clear(),e[0].universe.forEach((s,i)=>{let n=`${s.name}-PERP`;this.assetToIndexMap.set(n,i),this.exchangeToInternalNameMap.set(s.name,n)}),t[0].tokens.forEach(s=>{let i=t[0].universe.find(n=>n.tokens[0]===s.index);if(i){let n=`${s.name}-SPOT`,r=i.name,o=i.index;this.assetToIndexMap.set(n,1e4+o),this.exchangeToInternalNameMap.set(r,n)}}),this.consecutiveFailures=0}catch(e){throw this.consecutiveFailures++,this.checkMaxFailures(),e}}async getExchangeName(e){await this.ensureInitialized();for(let[t,s]of this.exchangeToInternalNameMap.entries())if(s===e)return t}async getAssetIndex(e){return await this.ensureInitialized(),this.assetToIndexMap.get(e)}async getAllAssets(){await this.ensureInitialized();let e=[],t=[];for(let[s,i]of this.assetToIndexMap.entries())s.endsWith("-PERP")?e.push(s):s.endsWith("-SPOT")&&t.push(s);return{perp:e,spot:t}}async convertSymbol(e,t="",s=""){await this.ensureInitialized();let i;if(t==="reverse"){for(let[n,r]of this.exchangeToInternalNameMap.entries())if(r===e)return n;i=e}else i=this.exchangeToInternalNameMap.get(e)||e;return s==="SPOT"?i.endsWith("-SPOT")||(i=e+"-SPOT"):s==="PERP"&&(i.endsWith("-PERP")||(i=e+"-PERP")),i}async convertSymbolsInObject(e,t=["coin","symbol"],s=""){if(await this.ensureInitialized(),typeof e!="object"||e===null)return this.convertToNumber(e);if(Array.isArray(e))return Promise.all(e.map(n=>this.convertSymbolsInObject(n,t,s)));let i={};for(let[n,r]of Object.entries(e))t.includes(n)?i[n]=await this.convertSymbol(r,"",s):n==="side"?i[n]=r==="A"?"sell":r==="B"?"buy":r:i[n]=await this.convertSymbolsInObject(r,t,s);return i}convertToNumber(e){if(typeof e=="string"){if(/^-?\d+$/.test(e))return parseInt(e,10);if(/^-?\d*\.\d+$/.test(e))return parseFloat(e)}return e}async convertResponse(e,t=["coin","symbol"],s=""){return this.convertSymbolsInObject(e,t,s)}};var x=class{info;exchange={};ws;subscriptions;custom;symbolConversion;rateLimiter;isValidPrivateKey=!1;walletAddress=null;_initialized=!1;_initializing=null;_privateKey;_walletAddress;vaultAddress=null;enableWs;baseUrl;testnet;constructor(e={}){let{enableWs:t=!0,privateKey:s,testnet:i=!1,walletAddress:n,vaultAddress:r,maxReconnectAttempts:o}=e;f.isBrowser&&(s&&console.warn("Warning: Storing private keys in browser environments is not recommended. Consider using a Web3 wallet provider instead."),window.isSecureContext||console.warn("Warning: Running in an insecure context. Some features may be limited.")),this.testnet=i,this.baseUrl=i?C.TESTNET:C.PRODUCTION,this.enableWs=t,this.rateLimiter=new W,this.symbolConversion=new z(this.baseUrl,this.rateLimiter),this.walletAddress=n||null,this.vaultAddress=r||null,this.info=new L(this.baseUrl,this.rateLimiter,this.symbolConversion,this),this.custom=new E(this),t?(!f.hasNativeWebSocket()&&f.isNode&&console.warn("Native WebSocket support is not available in this Node.js version. Attempting to use ws package..."),this.ws=new H(i,o),this.subscriptions=new q(this.ws,this.symbolConversion),f.supportsWebSocket()||(console.warn(`WebSocket support is not available. Please install the ws package to enable WebSocket features:

npm install ws
`),this.enableWs=!1)):(this.ws={},this.subscriptions={}),s?this.initializeWithPrivateKey(s,i):n&&(this._walletAddress=n,this.walletAddress=n)}async connect(){this._initialized||(this._initializing||(this._initializing=this.initialize()),await this._initializing)}async initialize(){if(!this._initialized)try{if(await this.symbolConversion.initialize(),this.enableWs)try{await this.ws.connect()}catch(e){let t=e instanceof Error?e.message:String(e);console.warn("Failed to establish WebSocket connection:",t),t.includes("Please install the ws package")&&(console.warn("To enable WebSocket support, please run: npm install ws"),this.enableWs=!1)}this._initialized=!0,this._initializing=null}catch(e){throw this._initializing=null,e}}async ensureInitialized(){await this.connect()}initializePrivateKey(e,t){try{let s=e.startsWith("0x")?e:`0x${e}`;new ee.Wallet(s),this.exchange=new O(t,s,this.info,this.rateLimiter,this.symbolConversion,this.walletAddress,this,this.vaultAddress),this.custom=new E(this.exchange,this.info,s,this.symbolConversion,this.walletAddress),this.isValidPrivateKey=!0}catch{console.warn("Invalid private key provided. Some functionalities will be limited."),this.isValidPrivateKey=!1}}createAuthenticatedProxy(e){return new Proxy({},{get:(t,s)=>{if(!this.isValidPrivateKey)throw new F("Invalid or missing private key. This method requires authentication.");return t[s]}})}initializeWithPrivateKey(e,t=!1){try{let s=e.startsWith("0x")?e:`0x${e}`;new ee.Wallet(s),this.exchange=new O(t,s,this.info,this.rateLimiter,this.symbolConversion,this.walletAddress,this,this.vaultAddress),this.custom=new E(this.exchange,this.info,s,this.symbolConversion,this.walletAddress),this.isValidPrivateKey=!0}catch{console.warn("Invalid private key provided. Some functionalities will be limited."),this.isValidPrivateKey=!1}}isAuthenticated(){return this.ensureInitialized(),this.isValidPrivateKey}isWebSocketConnected(){var e;return((e=this.ws)==null?void 0:e.isConnected())??!1}disconnect(){this.symbolConversion.stopPeriodicRefresh(),this.enableWs&&this.ws&&typeof this.ws.close=="function"&&this.ws.close(!0),this._initialized=!1,this._initializing=null}getBaseUrl(){return this.baseUrl}getRateLimiter(){return this.rateLimiter}};export{x as Hyperliquid,Fe as cancelOrderToAction,Me as floatToIntForHashing,ke as floatToUsdInt,K as floatToWire,De as getTimestampMs,V as normalizeTrailingZeros,N as orderToWire,ce as orderTypeToWire,G as orderWireToAction,S as removeTrailingZeros,J as signAgent,u as signL1Action,Y as signUsdTransferAction,A as signUserSignedAction,X as signWithdrawFromBridgeAction};
//# sourceMappingURL=index.mjs.map